## 动态规划算法

### 应用场景-背包问题

![image-20210526120544423](F:/Java%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/img/image-20210526120544423.png)

1. 要求达到的目标装入的背包的总价值最大，并且重量不超过容量
2. 要求装入的物品不能重复

### 动态规划算法基本介绍

1. 动态规划（Dynamic programming）算法的核心思想是：将大问题划分成小问题进行解决，从而一步步获取最优解的处理算法
2. 动态规划算法与分治算法类似，使基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解
3. 与分治算法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是相互独立的。（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行下一步求解）
4. 动态规划可以通过填表的方式来逐步推进，得到最优解

### 背包问题

思路分析：

- 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）

- 这里的问题属于01背包，即每个物品最多放一个。而无线背包可以转换为01背包

- 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[ i ] [ j ]表示在前i个物品中能够装入容量为j的背包中的最大价值。得到以下结果：

  1. v[ i ] [0] = v[0] [ j ] = 0;//表示填入表第一行和第一列都为0

  2. 当w[ i ] > j 时：v[ i ] [ j ] = v[ i-1 ] [ j ]；//当准备加入新增的商品的重量大于当前背包的容量时，就直接使用上一个单元格的装入策略。

  3. 当j >= w[ i ] 时：v[ i ] [ j ] = max{ v [ i-1 ] [ j ] , v[ i ] + v[ i-1 ] [ j -w [ i ] ]}；//当准备加入的新增的商品的重量小于等于当前背包的容量，装入的方式：

     ​										v[ i - 1 ] [ j ]：就是上一个单元格的装入的最大值

     ​										v[ i ]：表示当前商品的价值 v[ i-1 ] [ j - w[ i ]]：装入i-1商品，到剩余空间 j - w[ i ]的最大值	

     